<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="网络编程—下, Gustavo">
    <meta name="description" content="4. 案例01：手写一个RPC框架4.1 RPC原理RPC（Remote Procedure Call)，即远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络实现的技术。常见的 RPC 框架有：阿里的 Dubbo">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="referrer" content="no-referrer"/>
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>网络编程—下 | Gustavo</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    
    <style>
        body{
            background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>



    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Gustavo" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Gustavo</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Gustavo</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/gustavo1841" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/gustavo1841" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/279.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">网络编程—下</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/">
                                <span class="chip bg-color">计算机</span>
                            </a>
                        
                            <a href="/tags/Java/">
                                <span class="chip bg-color">Java</span>
                            </a>
                        
                            <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">
                                <span class="chip bg-color">网络编程</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="post-category">
                                计算机
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2025-04-24
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2025-04-25
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    10.8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    51 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="4-案例01：手写一个RPC框架"><a href="#4-案例01：手写一个RPC框架" class="headerlink" title="4. 案例01：手写一个RPC框架"></a>4. 案例01：手写一个RPC框架</h1><h2 id="4-1-RPC原理"><a href="#4-1-RPC原理" class="headerlink" title="4.1 RPC原理"></a>4.1 RPC原理</h2><p>RPC（Remote Procedure Call)，即远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络实现的技术。常见的 RPC 框架有：阿里的 Dubbo， Spring 旗下的 Spring Cloud Feign，Google 出品的 gRPC等。</p>
<p><img src="/../../../../images/%E8%AE%A1%E7%AE%97%E6%9C%BA/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20250424122741149.png"></p>
<ol>
<li><p>服务消费方（client）以本地调用方式调用服务</p>
</li>
<li><p>client stub（可以用nio，netty实现） 接收到调用后，负责将方法、参数等封装成能够进行网络传输的消息体</p>
</li>
<li><p>client stub 将消息进行编码并发送到服务端</p>
</li>
<li><p>server stub 收到消息后进行解码</p>
</li>
<li><p>server stub 根据解码结果调用提供者</p>
</li>
<li><p>本地服务执行并将结果返回给 server stub</p>
</li>
<li><p>server stub 将返回导入结果进行编码并发送至消费方</p>
</li>
<li><p>client stub 接收到消息并进行解码</p>
</li>
<li><p>服务消费方（client）得到结果RPC 的目标就是将 2-8 这些步骤都封装起来，用户无需关心这些细节，可以像调用本地方法一样即可完成远程服务调用。接下来我们基于 Netty 自己动手写一个 RPC，名为HeroRPC。</p>
</li>
</ol>
<h2 id="4-2-框架设计结构图"><a href="#4-2-框架设计结构图" class="headerlink" title="4.2 框架设计结构图"></a>4.2 框架设计结构图</h2><p><img src="/../../../../images/%E8%AE%A1%E7%AE%97%E6%9C%BA/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20250424122810535.png"></p>
<ul>
<li><p>服务的调用方：两个接口【服务提供方决定】+ 一个包含 main 方法的测试类</p>
</li>
<li><p>Client Stub: 一个客户端代理类 + 一个客户端业务处理类</p>
<ul>
<li><p>RPCProxy</p>
</li>
<li><p>ResultHandler</p>
</li>
</ul>
</li>
<li><p>服务的提供方：两个接口 + 两个实现类</p>
</li>
<li><p>Server Stub: 一个网络处理服务器 + 一个服务器业务处理类</p>
<ul>
<li><p>Server</p>
</li>
<li><p>InvokeHandler</p>
</li>
</ul>
</li>
</ul>
<p>注意：服务调用方的接口必须跟服务提供方的接口保持一致（包路径可以不一致）</p>
<p>最终要实现的目标是：在 TestNettyRPC 中远程调用 SkuServiceImpl 或UserServiceImpl中的方法</p>
<h2 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h2><h3 id="4-3-1-Server服务的提供方："><a href="#4-3-1-Server服务的提供方：" class="headerlink" title="4.3.1 Server服务的提供方："></a>4.3.1 Server服务的提供方：</h3><h4 id="1）SkuService接口与实现类"><a href="#1）SkuService接口与实现类" class="headerlink" title="1）SkuService接口与实现类"></a>1）SkuService接口与实现类</h4><pre class="line-numbers language-none"><code class="language-none">package org.example.rpc.producer;

/*
 * @author huangwei
 * @emaill 1142488172@qq.com
 * @date 2024/1/1 19:33
 */

public interface SkuService {
    String findName(String name);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">package org.example.rpc.producer.impl;

/*
 * @author huangwei
 * @emaill 1142488172@qq.com
 * @date 2024/1/1 19:34
 */

import org.example.rpc.producer.SkuService;

public class SkuServiceImpl implements SkuService {
    @Override
    public String findName(String name) {
        return "sku{}："+name;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2）UserService接口与实现类"><a href="#2）UserService接口与实现类" class="headerlink" title="2）UserService接口与实现类"></a>2）UserService接口与实现类</h4><pre class="line-numbers language-none"><code class="language-none">package org.example.rpc.producer;

/*
 * @author huangwei
 * @emaill 1142488172@qq.com
 * @date 2024/1/1 19:35
 */
public interface UserService {
    String findById();
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">package org.example.rpc.producer.impl;

/*
 * @author huangwei
 * @emaill 1142488172@qq.com
 * @date 2024/1/1 19:36
 */

import org.example.rpc.producer.UserService;

public class UserServiceImpl implements UserService {
    @Override
    public String findById() {
        return "user{id=1,username=weige}";
    }

}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码作为服务的提供方，我们分别编写了两个接口和两个实现类，供消费方远程调用。</p>
<h3 id="4-3-2-Server-Stub部分"><a href="#4-3-2-Server-Stub部分" class="headerlink" title="4.3.2 Server Stub部分"></a>4.3.2 Server Stub部分</h3><h4 id="1-传输的消息封装类："><a href="#1-传输的消息封装类：" class="headerlink" title="1.传输的消息封装类："></a>1.传输的消息封装类：</h4><pre class="line-numbers language-none"><code class="language-none">package org.example.rpc.server;

/*
 * @author huangwei
 * @emaill 1142488172@qq.com
 * @date 2024/1/1 19:37
 */

import java.io.Serializable;

public class ClassInfo implements Serializable {

    private String className;//类名
    private String methodName;//方法名
    private Class&lt;?&gt;[] types;//参数类型
    private Object[] objects;//参数列表

    public String getClassName() {
        return className;
    }

    public void setClassName(String className) {
        this.className = className;
    }

    public String getMethodName() {
        return methodName;
    }

    public void setMethodName(String methodName) {
        this.methodName = methodName;
    }

    public Class&lt;?&gt;[] getTypes() {
        return types;
    }

    public void setTypes(Class&lt;?&gt;[] types) {
        this.types = types;
    }

    public Object[] getObjects() {
        return objects;
    }

    public void setObjects(Object[] objects) {
        this.objects = objects;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>上述代码作为实体类用来封装消费方发起远程调用时传给服务方的数据。</p>
<h4 id="2-服务端业务处理类：Handler"><a href="#2-服务端业务处理类：Handler" class="headerlink" title="2.服务端业务处理类：Handler"></a>2.服务端业务处理类：Handler</h4><pre class="line-numbers language-none"><code class="language-none">package org.example.rpc.server;

import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import java.lang.reflect.Method;
import java.util.Set;
import org.reflections.Reflections;
/*
 * @author huangwei
 * @emaill 1142488172@qq.com
 * @date 2024/1/1 19:38
 */
//服务端业务处理类
public class InvokeHandler extends ChannelInboundHandlerAdapter {
    //得到某个接口下某个实现类的名字
    private String getImplClassName(ClassInfo classInfo)throws Exception{
        //服务方接口和实现类所在的包路径
        String interfacePath = "org.example.rpc.producer";
        int lastDot = classInfo.getClassName().lastIndexOf(".");
        //接口名称
        String interfaceName = classInfo.getClassName().substring(lastDot);
        //接口字节码对象
        Class superClass = Class.forName(interfacePath+interfaceName);
        //反射得到某个接口下的所有实现类
        Reflections reflections = new Reflections(interfacePath);
        Set&lt;Class&gt; implClassSet = reflections.getSubTypesOf(superClass);
        if(implClassSet.size()==0){
            System.out.println("未找到实现类");
            return null;
        }else if(implClassSet.size()&gt;1){
            /**
             * 思考一下，Spring是如何处理多个实现类的
             */
            return null;
        }else{
            //把集合转数组
            Class[] classes = implClassSet.toArray(new Class[0]);
            return classes[0].getName();//得到实现类名字
        }
    }

    /**
     * 读取客户端发来的数据并通过反射调用实现类方法
     * @param ctx
     * @param msg
     * @throws Exception
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ClassInfo classInfo = (ClassInfo) msg;
        Object clazz = Class.forName(getImplClassName(classInfo)).getDeclaredConstructor().newInstance();
        Method method = clazz.getClass().getMethod(classInfo.getMethodName(),classInfo.getTypes());
        //通过反射调用实现类方法
        Object result = method.invoke(clazz, classInfo.getObjects());
        ctx.writeAndFlush(result);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码作为业务处理类，读取消费方发来的数据，并根据得到的数据进行本地调用，然后把结果返回给消费方。</p>
<h4 id="3-RPC服务端程序：Server"><a href="#3-RPC服务端程序：Server" class="headerlink" title="3.RPC服务端程序：Server"></a>3.RPC服务端程序：Server</h4><pre class="line-numbers language-none"><code class="language-none">package org.example.rpc.server;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.codec.serialization.ClassResolvers;
import io.netty.handler.codec.serialization.ObjectDecoder;
import io.netty.handler.codec.serialization.ObjectEncoder;

/*
 * @author huangwei
 * @emaill 1142488172@qq.com
 * @date 2024/1/1 21:09
 * 服务端程序
 */
public class Server {
    private int port;
    public Server(int port){
        this.port = port;
    }

    /**
     * 用 Netty 实现的网络服务器，采用 Netty 自带的 ObjectEncoder 和 ObjectDecoder作为编
     * 解码器（为了降低复杂度，这里并没有使用第三方的编解码器），当然实际开发时也可以采用 JSON或XML。
     */
    public void start(){
        EventLoopGroup bossGrop = new NioEventLoopGroup();
        EventLoopGroup workeGrop = new NioEventLoopGroup();
        try {
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.group(bossGrop,workeGrop)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG,128)
                    .childOption(ChannelOption.SO_KEEPALIVE,true)
                    .localAddress(port).childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                        @Override
                        protected void initChannel(SocketChannel socketChannel) throws Exception {
                            ChannelPipeline pipeline = socketChannel.pipeline();
                            //编码器
                            pipeline.addLast("encoder", new ObjectEncoder());
                            //解码器
                            pipeline.addLast("decoder",new ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(null)));
                            //服务端业务处理类
                            pipeline.addLast(new InvokeHandler());
                        }
                    });

            ChannelFuture future = serverBootstrap.bind(port).sync();
            System.out.println("....... RPC is ready..........");
            future.channel().closeFuture().sync();



        }catch (Exception e){
            bossGrop.shutdownGracefully();
            workeGrop.shutdownGracefully();
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        new Server(9999).start();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>上述代码是用 Netty 实现的网络服务器，采用 Netty 自带的 ObjectEncoder 和 ObjectDecoder作为编解码器（为了降低复杂度，这里并没有使用第三方的编解码器），当然实际开发时也可以采用 JSON 或XML。</p>
<h3 id="4-3-3-Client-Stub部分"><a href="#4-3-3-Client-Stub部分" class="headerlink" title="4.3.3 Client Stub部分"></a>4.3.3 Client Stub部分</h3><h4 id="1）客户端业务处理类：ResultHandler"><a href="#1）客户端业务处理类：ResultHandler" class="headerlink" title="1）客户端业务处理类：ResultHandler"></a>1）客户端业务处理类：ResultHandler</h4><pre class="line-numbers language-'" data-language="'"><code class="language-'">package org.example.rpc.client;

/*
 * @author huangwei
 * @emaill 1142488172@qq.com
 * @date 2024/1/1 22:11
 */

import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;

/**
 * 客户端业务处理类
 */
public class ResultHandler extends ChannelInboundHandlerAdapter {

    private Object response;

    public Object getResponse(){
        return response;
    }

    /**
     * 读取服务端返回的数据（远程调用的结果）
     * @param ctx
     * @param msg
     * @throws Exception
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        response = msg;
        ctx.close();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码作为客户端的业务处理类读取远程调用返回的数据</p>
<h4 id="2）RPC客户端程序：RPC远程代理RPCProxy"><a href="#2）RPC客户端程序：RPC远程代理RPCProxy" class="headerlink" title="2）RPC客户端程序：RPC远程代理RPCProxy"></a>2）RPC客户端程序：RPC远程代理RPCProxy</h4><pre class="line-numbers language-none"><code class="language-none">package org.example.rpc.consumer;

import io.netty.bootstrap.Bootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.serialization.ClassResolvers;
import io.netty.handler.codec.serialization.ObjectDecoder;
import io.netty.handler.codec.serialization.ObjectEncoder;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import org.example.rpc.client.ResultHandler;
import org.example.rpc.server.ClassInfo;

/*
 * @author huangwei
 * @emaill 1142488172@qq.com
 * @date 2024/1/1 22:14
 * 客户端代理类
 */
public class RPCProxy {

    /**
     * 根据接口创建代理对象
     */
    public static Object create(final Class target){
        return Proxy.newProxyInstance(target.getClassLoader(), new Class[]{target}, new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                //封装ClassInfo
                ClassInfo classInfo = new ClassInfo();
                classInfo.setClassName(target.getName());
                classInfo.setMethodName(method.getName());
                classInfo.setObjects(args);
                classInfo.setTypes(method.getParameterTypes());
                //开始发送Netty数据
                EventLoopGroup group = new NioEventLoopGroup();
                final ResultHandler resultHandler = new ResultHandler();
                try {
                    Bootstrap b = new Bootstrap();
                    b.group(group)
                            .channel(NioSocketChannel.class)
                            .handler(new ChannelInitializer&lt;SocketChannel&gt;() {
                                @Override
                                protected void initChannel(SocketChannel socketChannel) throws Exception {
                                    ChannelPipeline pipeline = socketChannel.pipeline();
                                    //编码器
                                    pipeline.addLast("encoder", new ObjectEncoder());
                                    //解码器 构造方法第一个参数设置二进制数据的最大字节数 第二个参数设置具体使用哪个类解析器
                                    pipeline.addLast("decoder", new ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(null)));
                                    //客户端业务处理类
                                    pipeline.addLast("handler", resultHandler);
                                }
                            });
                    ChannelFuture future = b.connect("127.0.0.1",9999).sync();
                    future.channel().writeAndFlush(classInfo).sync();
                    future.channel().closeFuture().sync();
                }catch (Exception e){
                    e.printStackTrace();
                }finally {
                    group.shutdownGracefully();
                }
                return resultHandler.getResponse();
            }
        });
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码是用 Netty 实现的客户端代理类，采用 Netty 自带的 ObjectEncoder 和 ObjectDecoder作为编解码器（为了降低复杂度，这里并没有使用第三方的编解码器），当然实际开发时也可以采用 JSON或 XML。</p>
<h3 id="4-3-4-Client服务的调用方-消费方"><a href="#4-3-4-Client服务的调用方-消费方" class="headerlink" title="4.3.4 Client服务的调用方-消费方"></a>4.3.4 Client服务的调用方-消费方</h3><pre class="line-numbers language-none"><code class="language-none">package org.example.rpc;

import org.example.rpc.producer.SkuService;
import org.example.rpc.producer.UserService;
import org.example.rpc.consumer.RPCProxy;

/*
 * @author huangwei
 * @emaill 1142488172@qq.com
 * @date 2024/1/1 22:30
 * 服务调用方
 */
public class TestRPCV1 {
    public static void main(String[] args) {
        //第一次远程调用
        SkuService skuService = (SkuService) RPCProxy.create(SkuService.class);

        //第二次远程调用
        UserService service = (UserService) RPCProxy.create(UserService.class);
        System.out.println(skuService.findName("uid"));
        System.out.println(service.findById());

    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>消费方不需要知道底层的网络实现细节，就像调用本地方法一样成功发起了两次远程调用。</p>
<h1 id="5-案例02：手写一个Tomcat-V2-0"><a href="#5-案例02：手写一个Tomcat-V2-0" class="headerlink" title="5.案例02：手写一个Tomcat-V2.0"></a>5.案例02：手写一个Tomcat-V2.0</h1><p>本案例，咱们手写的是一个Web 容器命名为CustomCat，类似于Tomcat 的容器，用于处理HTTP请求。</p>
<p>Servlet 规范很复杂，所以本 Web 容器并没有去实现JavaEE 的Servlet 规范，所以说并不算是一个Servlet 容器。但是，其是类比着Tomcat 来写的，这里定义了自己的请求、响应及Servlet规范，分别命名为了HttpCustomRequest， HttpCustomResponse与HeroServlet。</p>
<h2 id="5-1CustomCat容器需求"><a href="#5-1CustomCat容器需求" class="headerlink" title="5.1CustomCat容器需求"></a>5.1CustomCat容器需求</h2><p>需求：软件工程师自定义一个Customcat提供给码农使用，码农只需要按照规定步骤，即可编写出自己的应用程序发布到CustomCat中供用户使用。</p>
<h3 id="5-1-1-角色"><a href="#5-1-1-角色" class="headerlink" title="5.1.1 角色"></a>5.1.1 角色</h3><p>Web容器（CustomCat）相关的角色：</p>
<ul>
<li><p>CustomCat开发者，编写Hero核心代码的软件工程师，下文简称：工程师</p>
</li>
<li><p>CustomCat使用者，应用程序业务功能开发的软件工程师，下文简称：码农</p>
</li>
<li><p>应用程序使用者：用户</p>
</li>
</ul>
<p>设计思路：</p>
<p><img src="/../../../../images/%E8%AE%A1%E7%AE%97%E6%9C%BA/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20250424133718677.png"></p>
<h3 id="5-1-2-使用步骤-码农"><a href="#5-1-2-使用步骤-码农" class="headerlink" title="5.1.2 使用步骤-码农"></a>5.1.2 使用步骤-码农</h3><p>码农使用CustomCat的步骤：</p>
<ul>
<li><p>码农编写自己的应用程序：</p>
<ul>
<li><p>导入CustomCat依赖坐标，并编写启动类</p>
</li>
<li><p>将自定义Servlet 放置到指定包下：例如 org.example.webapp</p>
</li>
</ul>
</li>
<li><p>码农发布自己的服务：</p>
<ul>
<li><p>码农将自己的接口URL按照固定规则发布：</p>
<ul>
<li>按照后缀， .do 、 .action 、 无后缀</li>
</ul>
</li>
<li><p>不管用何种规则：都将映射到自定义的Servlet（类名映射，忽略大小写）举例</p>
</li>
<li><pre><code>http://localhost:8080/aaa/bbb/userservlet?name=xiong 
<pre class="line-numbers language-none"><code class="language-none">
- 用户在访问应用程序：

  - 按照URL地址访问服务

  - 如果没有指定的Servlet，则访问默认的Servlet


### 5.1.3 CustomCat开发思路-工程师

工程师实现CustomCat思路：

- 第一步：创建CustomCat工程，导入依赖坐标

- 第二步：定义Servlet规范，HeroRequest、HeroResponse、HeroServlet

  - Servlet的规范其实是语言层面定义JavaEE

- 第三步：实现Servlet规范

  - HttpHeroRequest

  - HttpHeroResponse

  - DefaultHeroServlet【兜底】

- 第四步：编写CustomCat核心代码：

  - Server基于Netty实现：Servlet容器

  - ServerHandler处理请求，映射到Servlet的容器的自定义Servlet（Map容器）中去

- 第五步：打包发布CustomCat


## 5.2 创建工程

### 5.2.1 创建工程

创建一个普通的Maven 的Java 工程customcat。

### 5.2.2 导入依赖
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
<dependencies>
    <!-- netty-all依赖 -->
    <dependency>
        <groupid>io.netty</groupid>
        <artifactid>netty-all</artifactid>
    	<version>4.1.36.Final</version>
    </dependency>
    <!--lombok依赖-->
    <dependency>
        <groupid>org.projectlombok</groupid>
        <artifactid>lombok</artifactid>
        <version>1.18.6</version>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupid>org.dom4j</groupid>
        <artifactid>dom4j</artifactid>
        <version>2.1.3</version>
    </dependency>
    <dependency>
        <groupid>jaxen</groupid>
        <artifactid>jaxen</artifactid>
        <version>1.1.6</version>
    </dependency>
</dependencies>
<pre class="line-numbers language-none"><code class="language-none">
## 5.3 定义Servlet 规范

### 5.3.1 定义请求接口HttpCustomRequest
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
package org.example.servlet;

<p>import java.util.List;<br>import java.util.Map;</p>
<p>/**</p>
<ul>
<li>定义Servlet规范<br> */<br>public interface CustomRequest {<br> //获取URI，包含请求参数，即问号后的内容（那么如果是post请求，参数不在问号后，如何处理呢？）<br> String getUri();<br> //获取请求路径，其不包含请求参数<br> String getPath();<br> //获取请求方法(Get、Post等)<br> String getMethod();<br> //获取所有请求参数<br> Map&lt;String, List<string>&gt; getParameters();<br> //获取指定名称的请求参数<br> List<string> getParameters(String name);<br> //获取指定名称的请求参数的第一个值<br> String getParamenter(String name);<br>}</string></string></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">


### 5.3.2 定义响应接口CustomResponse
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.servlet;</p>
<p>/**</p>
<ul>
<li>Servlet响应规范<br> */<br>public interface CustomResponse {<br> //将响应写入到Channel<br> void write(String content)throws Exception;<br>}</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">
### 5.3.3 定义Servlet 规范HeroServlet
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>package org.example.servlet;</p>
<p>/**</p>
<ul>
<li>定义Servlet规范<br> */<br>public abstract class Servlet {<br> //处理http的get请求<br> public abstract void doGet(CustomRequest request, CustomResponse response) throws Exception;<br> //处理http的post请求<br> public abstract void doPost(CustomRequest request, CustomResponse response)throws Exception;<br>}</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">
## 5.4定义Tomcat服务器

### 5.4.1定义HttpCustomRequest类
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.http;</p>
<p>import io.netty.handler.codec.http.HttpRequest;<br>import io.netty.handler.codec.http.QueryStringDecoder;<br>import java.util.List;<br>import java.util.Map;<br>import org.example.servlet.CustomRequest;</p>
<p>/**</p>
<ul>
<li><p>实现对Servlet规范的默认是实现<br> */<br>public class HttpCustomRequest implements CustomRequest {</p>
<p> private HttpRequest request;<br> public HttpCustomRequest(HttpRequest request){<br> this.request = request;<br> }</p>
<p> @Override<br> public String getUri() {<br> return request.getUri();<br> }</p>
<p> @Override<br> public String getPath() {<br> QueryStringDecoder decoder = new QueryStringDecoder(request.uri());<br> return decoder.path();<br> }</p>
<p> @Override<br> public String getMethod() {<br> return request.method().name();<br> }</p>
<p> @Override<br> public Map&lt;String, List<string>&gt; getParameters() {<br> QueryStringDecoder decoder = new QueryStringDecoder(request.uri());<br> return decoder.parameters();<br> }</string></p>
<p> @Override<br> public List<string> getParameters(String name) {<br> return getParameters().get(name);<br> }</string></p>
<p> @Override<br> public String getParamenter(String name) {<br> List<string> parameters = getParameters(name);<br> if(parameters == null || parameters.size() == 0){<br>     return null;<br> }<br> return parameters.get(0);<br> }</string></p>
</li>
</ul>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


### 5.4.2定义服务器类HttpCustomResponse
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.http;</p>
<p>import io.netty.buffer.Unpooled;<br>import io.netty.channel.ChannelHandlerContext;<br>import io.netty.handler.codec.http.DefaultFullHttpResponse;<br>import io.netty.handler.codec.http.FullHttpResponse;<br>import io.netty.handler.codec.http.HttpHeaderNames;<br>import io.netty.handler.codec.http.HttpHeaderValues;<br>import io.netty.handler.codec.http.HttpHeaders;<br>import io.netty.handler.codec.http.HttpRequest;<br>import io.netty.handler.codec.http.HttpResponseStatus;<br>import io.netty.handler.codec.http.HttpUtil;<br>import io.netty.handler.codec.http.HttpVersion;<br>import io.netty.util.internal.StringUtil;<br>import java.util.List;<br>import java.util.Map;<br>import org.example.servlet.CustomRequest;<br>import org.example.servlet.CustomResponse;</p>
<p>/**</p>
<ul>
<li>实现对Servlet规范的默认是实现<br> */<br>public class HttpCustomResponse implements CustomResponse {<br> private HttpRequest request;<br> private ChannelHandlerContext context;<br> public HttpCustomResponse(HttpRequest request,ChannelHandlerContext context){<br> this.request = request;<br> this.context = context;<br> }<br> @Override<br> public void write(String content) throws Exception {<br> //处理空的情况<br> if(StringUtil.isNullOrEmpty(content)){<br>     return;<br> }<br> //创建响应对象<br> FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK,<br>         //根据响应体内容大型为response对象分配存储空间<br>         Unpooled.wrappedBuffer(content.getBytes(“UTF-8”)));<br><br> //获取响应头<br> HttpHeaders headers = response.headers();<br> //设置响应体类型 (apache tomcat是如何处理不同的响应类型的)<br> headers.set(HttpHeaderNames.CONTENT_TYPE,”text/json”);<br> //设置响应体长度<br> headers.set(HttpHeaderNames.CONTENT_LENGTH,response.content().readableBytes());<br> //设置缓存过期事件<br> headers.set(HttpHeaderNames.EXPIRES,0);<br> //若http请求是长连接，则响应也使用长连接<br> if(HttpUtil.isKeepAlive(request)){<br>     headers.set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);<br> }<br> //将响应写入到Channel<br> context.writeAndFlush(response);<br> }</li>
</ul>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
### **5.4.3** 定义DefaultHeroServlet类
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>package org.example.http;</p>
<p>import org.example.servlet.CustomRequest;<br>import org.example.servlet.CustomResponse;<br>import org.example.servlet.Servlet;</p>
<p>/**</p>
<ul>
<li><p>Tomcatv1中对Servlet规范的默认实现<br> */<br>public class DefaultHeroServlet extends Servlet {</p>
<p> @Override<br> public void doGet(CustomRequest request, CustomResponse response)throws Exception {<br> String uri = request.getUri();;<br> String name = uri.substring(0,uri.indexOf(“?”));<br> response.write(“404 - no this servlet ：”+name);<br> }</p>
<p> @Override<br> public void doPost(CustomRequest customRequest, CustomResponse customResponse)throws Exception {<br> doGet(customRequest, customResponse);<br> }</p>
</li>
</ul>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
### 5.4.4定义服务类Server
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>package org.example.server;</p>
<p>import io.netty.bootstrap.ServerBootstrap;<br>import io.netty.channel.ChannelFuture;<br>import io.netty.channel.ChannelInitializer;<br>import io.netty.channel.ChannelOption;<br>import io.netty.channel.ChannelPipeline;<br>import io.netty.channel.EventLoopGroup;<br>import io.netty.channel.nio.NioEventLoopGroup;<br>import io.netty.channel.socket.SocketChannel;<br>import io.netty.channel.socket.nio.NioServerSocketChannel;<br>import io.netty.handler.codec.http.HttpServerCodec;<br>import java.io.File;<br>import java.net.URL;<br>import java.util.Map;<br>import java.util.concurrent.ConcurrentHashMap;<br>import org.example.servlet.Servlet;<br>import org.example.util.DocumentNodeUtils;</p>
<p>/**</p>
<ul>
<li><p>tomcat功能实现<br> */<br>public class Server {<br> //key为Servlet的简单类名，value为对应Servlet实例<br> private Map&lt;String, Servlet&gt; nameToservletMap = new ConcurrentHashMap&lt;&gt;();<br> //key为Servlet的简单类名，value为对应Servlet类的全限定类名<br> private Map&lt;String,String&gt; nameToClassNameMap = new ConcurrentHashMap&lt;&gt;();<br> private String basePackage;<br> public Server(String basePackage){<br> this.basePackage = basePackage;<br> }</p>
<p> //启动tomcat<br> public void start() throws Exception {<br> //加载指定包中的所有Servlet的类名<br> cacheClassName(basePackage);<br> //启动server服务<br> runServer();<br> }</p>
<p> private void cacheClassName(String basePackage) {<br> URL resouce = this.getClass().getClassLoader().getResource(basePackage.replaceAll(“\.”,”/“));<br> //若目录没有资源则直接结束<br> if(resouce == null){<br>     return;<br> }<br> //将URL资源转换为File资源<br> File dir = new File(resouce.getFile());<br> //遍历指定包及子孙包中的所有文件，查找所有.class文件<br> for (File file:dir.listFiles()){<br>     if(file.isDirectory()){<br>         //若当前遍历的file为目录，则递归调用当前方法<br>         cacheClassName(basePackage+”.”+file.getClass());<br>     }else if(file.getName().endsWith(“.class”)){<br>         String simpleClassName = file.getName().replace(“.class”,””).trim();<br>         //key为简单的类名，value为全限定类名  （是否可以参考Spring的三级缓存机制？）<br>         nameToClassNameMap.put(simpleClassName.toLowerCase(),basePackage+”.”+simpleClassName);<br>     }<br> }<br> }</p>
<p> private void runServer()throws Exception {<br> EventLoopGroup parent = new NioEventLoopGroup();<br> EventLoopGroup child = new NioEventLoopGroup();<br> try {<br>     ServerBootstrap bootstrap = new ServerBootstrap();<br>     bootstrap.group(parent,child)<br>             //指定存放请求的队列长度<br>             .option(ChannelOption.SO_BACKLOG,1024)<br>             //指定是否用心跳检测机制来检测长连接的存活性，即客户端的存活性<br>             .childOption(ChannelOption.SO_KEEPALIVE,true)<br>             .channel(NioServerSocketChannel.class)<br>             .childHandler(new ChannelInitializer<socketchannel>() {<br>                 @Override<br>                 protected void initChannel(SocketChannel ch) throws Exception {<br>                     ChannelPipeline pipeline = ch.pipeline();<br>                     pipeline.addLast(new HttpServerCodec());<br>                     pipeline.addLast(new ServerHandler(nameToservletMap,nameToClassNameMap));<br>                 }<br>             });<br>     int port = initPort();<br>     ChannelFuture future = bootstrap.bind(port).sync();<br>     System.out.println(“tomcat启动成功，监听端口号为：”+port);<br>     future.channel().closeFuture().sync();<br> }finally {<br>     parent.shutdownGracefully();<br>     child.shutdownGracefully();<br> }<br> }</socketchannel></p>
<p> private int initPort()throws Exception {<br> //初始化端口，读取配置文件server.xml中的端口号<br> int port =(int) DocumentNodeUtils.readNode(“//port”);<br> return port;<br> }</p>
</li>
</ul>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
### **5.4.5** 定义服务端处理器ServerHandler
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>package org.example.server;</p>
<p>import io.netty.channel.ChannelHandlerContext;<br>import io.netty.channel.ChannelInboundHandlerAdapter;<br>import io.netty.handler.codec.http.HttpRequest;<br>import java.util.Map;<br>import java.util.Optional;<br>import org.example.http.DefaultHeroServlet;<br>import org.example.http.HttpCustomRequest;<br>import org.example.http.HttpCustomResponse;<br>import org.example.servlet.CustomRequest;<br>import org.example.servlet.CustomResponse;<br>import org.example.servlet.Servlet;<br>/**</p>
<ul>
<li><p>HeroCat服务端处理器</p>
</li>
<li></li>
<li><p>1）从用户请求URI中解析出要访问的Servlet名称</p>
</li>
<li><p>2）从nameToServletMap中查找是否存在该名称的key。若存在，则直接使用该实例，否则执<br> 行第3）步</p>
</li>
<li><p>3）从nameToClassNameMap中查找是否存在该名称的key，若存在，则获取到其对应的全限定<br> 性类名，</p>
</li>
<li><p>使用反射机制创建相应的serlet实例，并写入到nameToServletMap中，若不存在，则直<br> 接访问默认Servlet<br> */<br>public class ServerHandler extends ChannelInboundHandlerAdapter {<br> private Map&lt;String,Servlet&gt; nameTosServeltMap;<br> private Map&lt;String,String&gt; nameToClassNameMap;<br> public ServerHandler(Map&lt;String, Servlet&gt; nameToservletMap, Map&lt;String, String&gt; nameToClassNameMap) {<br> this.nameToClassNameMap = nameToClassNameMap;<br> this.nameTosServeltMap = nameToservletMap;<br> }</p>
<p> @Override<br> public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {<br> if(msg instanceof HttpRequest){<br>     HttpRequest request = (HttpRequest) msg;<br>     String uri = request.uri();<br>     //从请求中解析出要访问的Servlet名称<br>     String servletName = uri.substring(uri.lastIndexOf(“/“)+1,uri.indexOf(“?”)).toLowerCase();<br>     Servlet servlet = new DefaultHeroServlet();<br>     if(nameTosServeltMap.containsKey(servletName)){<br>         servlet = nameTosServeltMap.get(servletName);<br>     }else if(nameToClassNameMap.containsKey(servletName)){<br>         //double-check，双重检测锁<br>         if(nameTosServeltMap.get(servletName) == null){<br>             synchronized (this){<br>                 if(nameTosServeltMap.get(servletName) == null){<br>                     //获取当前Servlet的全限定类名<br>                     String className = nameToClassNameMap.get(servletName);<br>                     //使用反射机制创建Servlet实例<br>                     servlet = (Servlet) Class.forName(className).getDeclaredConstructor().newInstance();<br>                     //将servlet实例写入到nameToServletMap<br>                     nameTosServeltMap.put(servletName,servlet);<br>                 }<br>             }<br>         }<br>     }<br>     //代码走到这肯定不为空<br>     CustomRequest req = new HttpCustomRequest(request);<br>     CustomResponse res = new HttpCustomResponse(request,ctx);<br>     //根据不同的请求类型，调用Servlet实例的不同方法<br>     if(request.method().name().equalsIgnoreCase(“GET”)){<br>         servlet.doGet(req,res);<br>     }else if(request.method().name().equalsIgnoreCase(“POST”)){<br>         servlet.doPost(req,res);<br>     }<br>     ctx.close();<br> }<br> }</p>
<p> @Override<br> public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {<br> cause.printStackTrace();<br> ctx.close();<br> }</p>
</li>
</ul>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
### 5.4.6 定义启动类HeroCat
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>package org.example;</p>
<p>import org.example.server.Server;</p>
<p>/**</p>
<ul>
<li><p>需求：软件工程师自定义一个Tomcat提供给码农使用，码农只需要按照规定步骤，即可编写出自己的</p>
</li>
<li><p>应用程序发布到HeroCat中供用户使用。<br> <em>/<br>public class App {<br> /</em>*</p>
<ul>
<li>码农使用tomcatCat的步骤：</li>
<li>码农编写自己的应用程序：</li>
<li><pre><code> 导入HeroCat依赖坐标，并编写启动类
</code></pre>
</li>
<li><pre><code> 将自定义Servlet 放置到指定包下：例如 com.hero.webapp
</code></pre>
</li>
<li>码农发布自己的服务：</li>
<li><pre><code> 码农将自己的接口URL按照固定规则发布：
</code></pre>
</li>
<li><pre><code>     按照后缀， .do 、 .action 、 无后缀
</code></pre>
</li>
<li><pre><code> 不管用何种规则：都将映射到自定义的Servlet（类名映射，忽略大小写）举例
</code></pre>
</li>
<li>用户在访问应用程序：</li>
<li><pre><code> 按照URL地址访问服务
</code></pre>
</li>
<li><pre><code> 如果没有指定的Servlet，则访问默认的Servlet
</code></pre>
</li>
<li></li>
<li><pre><code> http://localhost:8080/skuServlet?name=xiong
</code></pre>
</li>
</ul>
<p>  */</p>
<p> /**</p>
<ul>
<li>工程师开发Tomcat的思路</li>
<li>第一步：创建HeroCat工程，导入依赖坐标</li>
<li>第二步：定义Servlet规范，HeroRequest、HeroResponse、HeroServlet</li>
<li>Servlet的规范其实是语言层面定义JavaEE</li>
<li>第三步：实现Servlet规范HttpHeroRequest、HttpHeroResponse、DefaultHeroServlet【兜底】</li>
<li>第四步：编写HeroCat核心代码：</li>
<li><pre><code> HeroCatServer基于Netty实现：Servlet容器
</code></pre>
</li>
<li><pre><code> HeroCatHandler处理请求，映射到Servlet的容器的自定义Servlet（Map容器）中去
</code></pre>
</li>
<li>第五步：打包发布HeroCat<br>  */</li>
</ul>
<p> public static void main(String[] args) throws Exception {<br>     //<a target="_blank" rel="noopener" href="http://localhost:8080/skuServlet?name=huangwei">http://localhost:8080/skuServlet?name=huangwei</a><br>     Server server = new Server(“org.example.webapp”);<br>     server.start();<br> }</p>
</li>
</ul>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


## 5.5 定义业务SkuServlet
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.webapp;</p>
<p>import org.example.servlet.CustomRequest;<br>import org.example.servlet.CustomResponse;<br>import org.example.servlet.Servlet;</p>
<p>/**</p>
<ul>
<li><p>业务方法<br> */<br>public class SkuServlet extends Servlet {</p>
<p> @Override<br> public void doGet(CustomRequest request, CustomResponse response) throws Exception {<br> String uri = request.getUri();<br> String path = request.getPath();<br> String method = request.getMethod();<br> String name  = request.getParamenter(“name”);<br> String content = “uri=”+uri+”\n”+”path=”+path+”\n”+”method=”+method+”\n”+”param = “+name;<br> response.write(content);<br> }</p>
<p> @Override<br> public void doPost(CustomRequest request, CustomResponse response) throws Exception {<br> doGet(request, response);<br> }</p>
</li>
</ul>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


# 6.案例03：600W+连接网络应用实战

## 6.1 Disruptor框架

### 6.1.1 什么是Disruptor？

LMAX是英国外汇交易公司，目标是成为世界上最快的交易平台。为了实现这一点，这家公司的技术团队使用 Java 平台实现非常低的延迟和高吞吐量的交易系统。经过一系列性能测试表明，使用队列在系统的各个阶段之间传递数据会导致延迟，当然吞吐量也就很难上的去，因此他们技术团队专注于优化这个领域，所以Disruptor诞生了。

Disruptor是一个通用解决方案，用于解决并发编程中的难题（低延迟与高吞吐量）。其本质还是一个队列（环形），与其他队列类似，也是基于生产者消费者模式设计，只不过这个队列很特别是一个环形队列。这个队列能够在无锁的条件下进行并行消费，也可以根据消费者之间的依赖关系进行先后次序消费。

说的简单点：生产者向RingBuffer中写入元素，消费从RingBuffer中消费元素。基于 Disruptor 开发的系统单线程能支撑每秒 600 万订单。

它与并发编程中的阻塞队列有什么不同？

- 低延时高通吐
- 快，它实在是太快了

![](../../../../images/计算机/Java/网络编程/image-20250424135542760.png)

6.1.2 通用步骤

1. 创建工厂类，用于生产Event对象

2. 创建Consumer监听类，用于监听，并处理Event

3. 创建Disruptor对象，并初始化一系列参数：工厂类、RingBuffer大小、线程池、单生产者或多生产者、Event等待策略

4. 编写Producer组件，向Disruptor容器中去投递Event

### 6.1.3 核心概念

#### 1）Disruptor

它是一个辅助类，持有RingBuffer、消费者线程池Executor、消费者仓 ConsumerRepository等引用。

#### 2）RingBuffer环形缓存器

RingBuffer基于数组的实现，数据结构是个首尾相接的环，用做在不同上下文（线程）间传递数据的buffer。RingBuffer拥有一个Sequencer序号器，这个序号器指向数组中下一个可用元素。

 ![](../../../../images/计算机/Java/网络编程/image-20250424135621361.png)

#### 3）Sequencer序号器

Sequencer序号器是Disruptor核心。

此接口有两个实现类：

- SingleProducerSequencer 单生产者

- MultiProducerSequencer 多生产者


#### 4）Sequence序号

Sequencer序号器中有Sequence序号，通过顺序递增的序号来编号和管理进行交换的Event。

Event的处理过程总是沿着序号逐个递增处理。

一个Sequence用于跟踪标识某个特定的事件处理者的处理进度。Producer和Consumer都有自己的Sequence，用来判断Consumer和Producer之间平衡，防止生产快，消费慢或生产慢，消费快等情况【上下游速度不一致问题】。相当于标识进度了

- 解决上下游消费速度不一致问题
- 异步提速

- 削峰填谷


#### 5）WaitStrategy等待策略

决定一个Consumer将如何等待Producer将Event置入RingBuffer

主要策略有：

- BlockingWaitStrategy：阻塞等待策略，最低效的策略，但其对CPU的消耗最小并且在各种不同部署环境中能提供更加一致的性能表现。

- SleepingWaitStrategy：休眠等待策略，性能表现跟BlockingWaitStrategy差不多，对CPU的消耗也类似，但其对生产者线程的影响最小，适合用于异步日志类似的场景。

- YieldingWaitStrategy：产生等待策略，性能最好，适合用于低延迟的系统，在要求极高性能且事件处理线程数小于CPU逻辑核心数的场景中，推荐使用。是无锁并行


#### 6）Event

从Producer到Consumer过程中所处理的数据单元

#### 7）EventHandler

由用户实现，并且代表Disruptor中的一个消费者的接口，我们的消费者逻辑都需要写在这里。

## 6.2 案例04：单生产者单消费者

目标：演示Disruptor高性能队列的基本用法，创建循环100个订单消息并消费之

步骤：

1. 创建OrderEventFactory来产生OrderEvent实例对象

2. 创建Consumer处理者OrderEventHandler，当Producer投递一条条数据时此Handler进行处理

3. 编写核心类Main创建disruptor对象，让其与Consumer处理者OrderEventHandler绑定，启动disruptor

4. 通过disruptor对象获取到ringBuffer容器。

5. 创建生产者OrderEventProducer，将消息放到RingBuffer容器

6. 循环100次，通过sendData()投递消息。sendData()方法的最后将消息发布出去，只有发布出去，消费者才能收到

![](../../../../images/计算机/Java/网络编程/image-20250424135810138.png)

### 1）OrderEvent

定义需要处理的OrderEvent类
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.entity;</p>
<p>/**</p>
<ul>
<li><p>订单对象，生产者要生产订单对象，消费者消费订单对象<br> */<br>public class OrderEvent {<br> private long value;//订单价格</p>
<p> public long getValue() {<br> return value;<br> }</p>
<p> public OrderEvent setValue(long value) {<br> this.value = value;<br> return this;<br> }</p>
</li>
</ul>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


### 2）OrderEventFactory

定义工厂类OrderEventFactory，用于创建OrderEvent对象。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.single;</p>
<p>import com.lmax.disruptor.EventFactory;<br>import org.example.entity.OrderEvent;</p>
<p>//建立一个工厂类，用于创建Event的实例（OrderEvent)<br>public class OrderEventFactory implements EventFactory<orderevent> {</orderevent></p>
<pre><code>@Override
public OrderEvent newInstance() {
    //返回空的数据对象，不是null，OrderEvent，value属性还没有赋值
    return new OrderEvent();
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
### 3）OrderEventHandler

定义Event监听及处理类OrderEventHandler，用于处理OrderEvent
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.single;</p>
<p>import com.lmax.disruptor.EventHandler;<br>import org.example.entity.OrderEvent;</p>
<p>//消费者<br>public class OrderEventHandler implements EventHandler<orderevent> {</orderevent></p>
<pre><code>@Override
public void onEvent(OrderEvent orderEvent, long l, boolean b) throws Exception {
    //取出订单对象的价格
    System.out.println("消费者："+orderEvent.getValue());
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


### 4）TestDisruptor

定义测试类，创建Disruptor对象，并初始化一系列参数：工厂类、RingBuffer大小、线程池、单生产者或多生产者、Event等待策略。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example;</p>
<p>import com.lmax.disruptor.*;<br>import com.lmax.disruptor.dsl.Disruptor;<br>import com.lmax.disruptor.dsl.ProducerType;<br>import org.example.entity.Order;<br>import org.example.entity.OrderEvent;<br>import org.example.mutiple.ConsumerHandler;<br>import org.example.mutiple.EventExceptionHandler;<br>import org.example.mutiple.Producer;<br>import org.example.single.OrderEventFactory;<br>import org.example.single.OrderEventHandler;<br>import org.example.single.OrderEventProducer;</p>
<p>import java.nio.ByteBuffer;<br>import java.util.UUID;<br>import java.util.concurrent.CountDownLatch;<br>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;<br>import java.util.concurrent.TimeUnit;</p>
<p>/**</p>
<ul>
<li><ol>
<li>创建工厂类，用于生产Event对象</li>
</ol>
</li>
<li><ol start="2">
<li>创建Consumer监听类，用于监听，并处理Event</li>
</ol>
</li>
<li><ol start="3">
<li>创建Disruptor对象，并初始化一系列参数：工厂类、RingBuffer大小、线程池、单生产者或多生产者、Event等待策略</li>
</ol>
</li>
<li><ol start="4">
<li>编写Producer组件，向Disruptor容器中去投递Event<br> <em>/<br>public class App<br>{<br> public static void main( String[] args ) throws InterruptedException {<br>  //单生产者消费<br>  OrderEventFactory orderEventFactory = new OrderEventFactory();<br>  int ringBufferSize = 8;<br>  ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());<br>  /</em>*<ul>
<li>1、eventFactory：消息工厂对象</li>
<li>2、ringBufferSize：容器长度</li>
<li>3、executor：线程池，建议使用自定义的线程池，线程上限</li>
<li>4、ProducerType：单生产者或多生产者</li>
<li>5、waitStrategy：等待策略<br>   */<br>  //1、实例化disrupotor对象<br>  Disruptor<orderevent> disruptor = new Disruptor<orderevent>(orderEventFactory,ringBufferSize,executor,<br> ProducerType.SINGLE,new BlockingWaitStrategy());</orderevent></orderevent></li>
</ul>
<p>  //2、添加消费者的监听(去构建disruptor与消费者的一个关联关系)<br>  disruptor.handleEventsWith(new OrderEventHandler());<br>  //3、启动disruptor<br>  disruptor.start();<br>  //4、取到容器后通过生产者去生产消息<br>  //获取实际存储数据的容器RingBuffer<br>  RingBuffer<orderevent> ringBuffer = disruptor.getRingBuffer();<br>  //生产者<br>  OrderEventProducer producer = new OrderEventProducer(ringBuffer);<br>  //先初始化ByteBuffer长度为8个字节<br>  ByteBuffer byteBuffer = ByteBuffer.allocate(1024);<br>  //生产100个orderEvent-&gt;value-&gt;i 0-99<br>  for(long i=0;i&lt;100;i++){<br>      byteBuffer.putLong(0,i);<br>      producer.sendData(byteBuffer);<br>  }<br>  disruptor.shutdown();<br>  executor.shutdown();</orderevent></p>
</li>
</ol>
<p> }</p>
</li>
</ul>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


### 5）OrderEventProducer

定义Producer类，向Disruptor容器中去投递数据。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.single;</p>
<p>import com.lmax.disruptor.RingBuffer;<br>import java.nio.ByteBuffer;<br>import org.example.entity.OrderEvent;</p>
<p>public class OrderEventProducer {</p>
<pre><code>//ringBuffer存储数据的一个容器
private RingBuffer&lt;OrderEvent&gt; ringBuffer;
public OrderEventProducer(RingBuffer&lt;OrderEvent&gt; ringBuffer) {
    this.ringBuffer = ringBuffer;
}

//生产者投递的数据
public void sendData(ByteBuffer data){
    //1、在生产者发送消息时，首先要从ringBuffer中找到一个可用的序号
    long sequnce = ringBuffer.next();
    try {
        //2.根据这个序号找到具体的OrderEvent元素, 此时获取到的OrderEvent对象是一个没有被赋值的空对象。value
        OrderEvent orderEvent = ringBuffer.get(sequnce);
        orderEvent.setValue(data.getLong(0));
    }catch (Exception e){
        e.printStackTrace();
    }finally {
        //4、提交发布操作，生产者最后要发布消息
        ringBuffer.publish(sequnce);
    }
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
![](../../../../images/计算机/Java/网络编程/image-20250424140236528.png)

## 6.3 案例05：多生产者和多消费者

时刻01

![](../../../../images/计算机/Java/网络编程/image-20250424140258108.png)

时刻02

![](../../../../images/计算机/Java/网络编程/image-20250424140310464.png)

### 1）Order
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.entity;</p>
<p>/**</p>
<ul>
<li><p>Disruptor 中的Event<br> */<br>public class Order {<br> private String id;<br> private String name;<br> private double price;</p>
<p> public String getId() {<br> return id;<br> }</p>
<p> public Order setId(String id) {<br> this.id = id;<br> return this;<br> }</p>
<p> public String getName() {<br> return name;<br> }</p>
<p> public Order setName(String name) {<br> this.name = name;<br> return this;<br> }</p>
<p> public double getPrice() {<br> return price;<br> }</p>
<p> public Order setPrice(double price) {<br> this.price = price;<br> return this;<br> }</p>
</li>
</ul>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
### 2）ConsumerHandler
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>package org.example.mutiple;</p>
<p>import com.lmax.disruptor.WorkHandler;<br>import java.util.Random;<br>import java.util.concurrent.TimeUnit;<br>import java.util.concurrent.atomic.AtomicInteger;<br>import org.example.entity.Order;</p>
<p>public class ConsumerHandler implements WorkHandler<order> {<br>    //每个消费者都有自己的id<br>    private String comsumerId;<br>    //计数统计，多个消费者，所有的消费者总共消费了多个消息<br>    private static AtomicInteger count = new AtomicInteger(0);<br>    private Random random = new Random();</order></p>
<pre><code>public ConsumerHandler(String comsumerId){
    this.comsumerId = comsumerId;
}

@Override
public void onEvent(Order event) throws Exception {
    //模拟消费者处理消息的耗时
    TimeUnit.MILLISECONDS.sleep(1* random.nextInt(5));
    System.out.println("当前消费者："+this.comsumerId+"，消费信息ID："+event.getId());
    //count计数器+1，表示消费了一个消息
    count.incrementAndGet();
}
//返回所有消费者总共消费的消息个数
public int getCount(){
    return count.get();
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
### 3）Producer
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>package org.example.mutiple;</p>
<p>import com.lmax.disruptor.RingBuffer;<br>import org.example.entity.Order;</p>
<p>public class Producer {<br>    private RingBuffer<order> ringBuffer;</order></p>
<pre><code>//为生产者绑定ringBuffer
public Producer(RingBuffer&lt;Order&gt; ringBuffer){
    this.ringBuffer = ringBuffer;
}

//发送数据
public void sendData(String uuid){
    //1、获取到可用的sequece
    long sequece = ringBuffer.next();
    try {
        Order order = ringBuffer.get(sequece);
        order.setId(uuid);
    }catch (Exception e){
        e.printStackTrace();
    }finally {
        //发布序号
        ringBuffer.publish(sequece);
    }
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
### 4）TestMultiDisruptor
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>package org.example;</p>
<p>import com.lmax.disruptor.BlockingWaitStrategy;<br>import com.lmax.disruptor.EventFactory;<br>import com.lmax.disruptor.RingBuffer;<br>import com.lmax.disruptor.SequenceBarrier;<br>import com.lmax.disruptor.WorkerPool;<br>import com.lmax.disruptor.YieldingWaitStrategy;<br>import com.lmax.disruptor.dsl.Disruptor;<br>import com.lmax.disruptor.dsl.ProducerType;<br>import com.sun.org.apache.xpath.internal.operations.Or;<br>import java.nio.ByteBuffer;<br>import java.sql.Time;<br>import java.util.UUID;<br>import java.util.concurrent.CountDownLatch;<br>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;<br>import java.util.concurrent.TimeUnit;<br>import org.example.entity.Order;<br>import org.example.entity.OrderEvent;<br>import org.example.mutiple.ConsumerHandler;<br>import org.example.mutiple.EventExceptionHandler;<br>import org.example.mutiple.Producer;<br>import org.example.single.OrderEventFactory;<br>import org.example.single.OrderEventHandler;<br>import org.example.single.OrderEventProducer;<br>import org.w3c.dom.events.EventException;</p>
<p>/**</p>
<ul>
<li><ol>
<li>创建工厂类，用于生产Event对象</li>
</ol>
</li>
<li><ol start="2">
<li>创建Consumer监听类，用于监听，并处理Event</li>
</ol>
</li>
<li><ol start="3">
<li>创建Disruptor对象，并初始化一系列参数：工厂类、RingBuffer大小、线程池、单生产者或多生产者、Event等待策略</li>
</ol>
</li>
<li><ol start="4">
<li><p>编写Producer组件，向Disruptor容器中去投递Event<br> <em>/<br>public class App<br>{<br> public static void main( String[] args ) throws InterruptedException {<br>  /</em>*</p>
<ul>
<li>多实例消费者<br>   <em>/<br>  //1、创建RingBuffer，Disruptor包含RingBuffer<br>  RingBuffer<order> mutil_ringBuffer = RingBuffer.create(<br> ProducerType.MULTI,//多生产者<br> new EventFactory<order>() {<br>     @Override<br>     public Order newInstance() {<br>         return new Order();<br>     }<br> },<br> 1024</order></order></em>1024,<br> new YieldingWaitStrategy()</li>
</ul>
<p>  );<br>  //2、创建ringBuffer屏障<br>  SequenceBarrier sequenceBarrier = mutil_ringBuffer.newBarrier();<br>  //3、创建多个消费者数组<br>  ConsumerHandler[] consumers = new ConsumerHandler[10];<br>  for(int i=0;i&lt;consumers.length;i++){<br>      consumers[i] = new ConsumerHandler(“C”+i);<br>  }<br>  //4、构建多消费者工作池<br>  WorkerPool<order> workerPool = new WorkerPool<order>(mutil_ringBuffer,sequenceBarrier,new EventExceptionHandler(),consumers);</order></order></p>
<p>  //5、设置多个消费者的sequence序号，用于单独统计消费者的消费进度。消费进度让RingBuffer知道<br>  mutil_ringBuffer.addGatingSequences(workerPool.getWorkerSequences());<br>  //6、启动workPool<br>  workerPool.start(Executors.newFixedThreadPool(5));//在实际开发，自定义线程池<br>  //要生产100个生产者，每个生产者发送100个数据，总共投递10000<br>  final CountDownLatch latch = new CountDownLatch(1);<br>  //设置100个生产者向ringbuffer中去投递数据<br>  for(int i=0;i&lt;100;i++){<br>      final Producer producer_mutil = new Producer(mutil_ringBuffer);<br>      new Thread(()-&gt;{<br>          try {<br>              //每次一个生产者创建后就处理等待。先创建100个生产者，创建完100个生产者后再去发送数据<br>              latch.await();<br>          }catch (Exception e){<br>              e.printStackTrace();<br>          }<br>          for(int j=0;j&lt;100;j++){<br>              producer_mutil.sendData(UUID.randomUUID().toString());<br>          }<br>      }).start();<br>  }<br>  //把所有线程创建完<br>  TimeUnit.SECONDS.sleep(2);<br>  //唤醒<br>  latch.countDown();<br>  //休眠10s，让生产者把100次循环走完<br>  TimeUnit.SECONDS.sleep(10);<br>  System.out.println(“任务总数：”+consumers[0].getCount());</p>
</li>
</ol>
<p> }</p>
</li>
</ul>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
### 5) EventExceptionHandler
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>package org.example.mutiple;</p>
<p>import com.lmax.disruptor.ExceptionHandler;<br>import org.example.entity.Order;</p>
<p>public class EventExceptionHandler implements ExceptionHandler<order> {<br>    //消费时出现异常<br>    @Override<br>    public void handleEventException(Throwable throwable, long l, Order order) {<br>        System.out.println(“消费出现异常”);<br>    }<br>    //启动时出现异常<br>    @Override<br>    public void handleOnStartException(Throwable throwable) {</order></p>
<pre><code>}
//停止时出现异常
@Override
public void handleOnShutdownException(Throwable throwable) {

}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
## 6.4 案例06：使用Disruptor提升Netty应用性能

### 6.4.1 构建Netty网络模型

![](../../../../images/计算机/Java/网络编程/image-20250424140709882.png)

#### 1）构建基础网络应用环境

- disruptor-netty-com是通用包

- disruptor-netty-client是客户端

- disruptor-netty-server是服务端


#### 2）TranslatorData

传输的数据对象
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.entity;</p>
<p>import java.io.Serializable;</p>
<p>public class TranslatorData implements Serializable {</p>
<pre><code>private String id;
private String name;
private String message;

public String getId() {
    return id;
}

public TranslatorData setId(String id) {
    this.id = id;
    return this;
}

public String getName() {
    return name;
}

public TranslatorData setName(String name) {
    this.name = name;
    return this;
}

public String getMessage() {
    return message;
}

public TranslatorData setMessage(String message) {
    this.message = message;
    return this;
}

@Override
public String toString() {
    return "TranslatorData{" +
            "id='" + id + '\'' +
            ", name='" + name + '\'' +
            ", message='" + message + '\'' +
            '}';
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
#### 3）NettyServe
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>package org.example.netty.server;</p>
<p>import io.netty.bootstrap.ServerBootstrap;<br>import io.netty.buffer.PooledByteBufAllocator;<br>import io.netty.channel.AdaptiveRecvByteBufAllocator;<br>import io.netty.channel.ChannelFuture;<br>import io.netty.channel.ChannelInitializer;<br>import io.netty.channel.ChannelOption;<br>import io.netty.channel.EventLoopGroup;<br>import io.netty.channel.nio.NioEventLoopGroup;<br>import io.netty.channel.socket.SocketChannel;<br>import io.netty.channel.socket.nio.NioServerSocketChannel;<br>import io.netty.handler.logging.LogLevel;<br>import io.netty.handler.logging.LoggingHandler;<br>import org.example.factory.MarshallingCodeCFactory;</p>
<p>public class NettyServer {<br>    public NettyServer()  {<br>        //1、创建两个工作线程组：一个用于接受网络请求，另一个用于实际处理业务的线程组<br>        EventLoopGroup bossGroup = new NioEventLoopGroup();<br>        EventLoopGroup workeGroup = new NioEventLoopGroup();<br>        //2、辅助类<br>        ServerBootstrap bootstrap = new ServerBootstrap();<br>        try {<br>            bootstrap.group(bossGroup,workeGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .option(ChannelOption.SO_BACKLOG,1024)<br>                    //表示缓冲区动态调配(自适应)<br>                    .option(ChannelOption.RCVBUF_ALLOCATOR, AdaptiveRecvByteBufAllocator.DEFAULT)<br>                    //缓存区 池化操作<br>                    .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)<br>                    .handler(new LoggingHandler(LogLevel.INFO))<br>                    .childHandler(new ChannelInitializer<socketchannel>() {</socketchannel></p>
<pre><code>                    @Override
                    protected void initChannel(SocketChannel ch) throws Exception {
                        ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());
                        ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());
                        ch.pipeline().addLast(new ServerHandler());
                    }
                });

        //绑定端口，同步等等请求连接
        ChannelFuture cf = bootstrap.bind(8765).sync();
        System.err.println("Server Startup......");
        cf.channel().closeFuture().sync();
    }catch (Exception e){
        e.printStackTrace();
    }finally {
        bossGroup.shutdownGracefully();
        workeGroup.shutdownGracefully();
        System.out.println("Server Shutdown......");
    }
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
#### 4）ServerHandler
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>package org.example.netty.server;</p>
<p>import io.netty.channel.ChannelHandlerContext;<br>import io.netty.channel.ChannelInboundHandlerAdapter;<br>import org.example.entity.TranslatorData;<br>import org.example.factory.RingBufferWorkerPoolFactory;<br>import org.example.producer.MessageProducer;</p>
<p>public class ServerHandler extends ChannelInboundHandlerAdapter {<br>    //无disruptor<br>    @Override<br>    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {<br>        TranslatorData request = (TranslatorData) msg;<br>        System.out.println(“Server端：”+request.toString());<br>        //数据库持久化操作 IO读写——》交给一个线程池，去异步调用执行<br>        TranslatorData response = new TranslatorData();<br>        response.setId(“resp：”+request.getId());<br>        response.setName(“resp：”+request.getName());<br>        response.setMessage(“resp：”+request.getMessage());<br>        //写出response响应信息：<br>        ctx.writeAndFlush(response);</p>
<pre><code>}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
#### 5）NettyClient
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>package org.example.netty.client;</p>
<p>import io.netty.bootstrap.Bootstrap;<br>import io.netty.buffer.PooledByteBufAllocator;<br>import io.netty.channel.AdaptiveRecvByteBufAllocator;<br>import io.netty.channel.Channel;<br>import io.netty.channel.ChannelFuture;<br>import io.netty.channel.ChannelInitializer;<br>import io.netty.channel.ChannelOption;<br>import io.netty.channel.EventLoopGroup;<br>import io.netty.channel.nio.NioEventLoopGroup;<br>import io.netty.channel.socket.SocketChannel;<br>import io.netty.channel.socket.nio.NioSocketChannel;<br>import io.netty.handler.logging.LogLevel;<br>import io.netty.handler.logging.LoggingHandler;<br>import org.example.entity.TranslatorData;<br>import org.example.factory.MarshallingCodeCFactory;</p>
<p>public class NettyClinet {</p>
<pre><code>public static final String HOST = "127.0.0.1";

public static final int PORT = 8765;

//扩展 完善 池化 ConcurrentHashMap&lt;Key --- String,value ---&gt;Channel&gt;
private Channel channel;

//1、创建工作线程组：用于实际处理业务的线程组
private EventLoopGroup workGroup = new NioEventLoopGroup();

private ChannelFuture cf;

public NettyClinet() {
    this.connect(HOST, PORT);
}
private void connect(String host, int port) {
    //2、辅助类 注意Client和Server是不一样的
    Bootstrap bootstrap = new Bootstrap();
    try {
        //绑定线程组
        bootstrap.group(workGroup)
                .channel(NioSocketChannel.class)
                //表示缓冲区动态调配 自适应
                .option(ChannelOption.RCVBUF_ALLOCATOR, AdaptiveRecvByteBufAllocator.DEFAULT)
                //缓存区 池化操作
                .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
                .handler(new LoggingHandler(LogLevel.INFO))
                .handler(new ChannelInitializer&lt;SocketChannel&gt;() {
                    @Override
                    protected void initChannel(SocketChannel ch) throws Exception {
                        //网络传递对象，客户端和服务端都要做编码和解码操作
                        ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());
                        ch.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());
                        ch.pipeline().addLast(new ClientHandler());
                    }
                });
        //绑定端口，同步等待请求连接
        this.cf = bootstrap.connect(host, port).sync();
        System.err.println("Client connected.....");
        //进行数据发送，首先获取channel
        this.channel = cf.channel();

    } catch (Exception e) {
        e.printStackTrace();
    }
}
//发送数据的方法，提供给外部使用
public void sendData() {
    for (int i = 0; i &lt; 6000000; i++) {
        TranslatorData request = new TranslatorData();
        request.setId(String.valueOf(i));
        request.setName("请求消息名称 "+i);
        request.setMessage("请求消息内容 "+i);
        this.channel.writeAndFlush(request);
    }
}

public void close()throws Exception{
    cf.channel().closeFuture().sync();
    workGroup.shutdownGracefully();
    System.out.println("Server Shtudown.....");
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
#### 6）ClientHandler
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>package org.example.netty.client;</p>
<p>import io.netty.channel.ChannelHandlerContext;<br>import io.netty.channel.ChannelInboundHandlerAdapter;<br>import io.netty.util.ReferenceCountUtil;<br>import org.example.entity.TranslatorData;<br>import org.example.factory.RingBufferWorkerPoolFactory;<br>import org.example.producer.MessageProducer;</p>
<p>public class ClientHandler extends ChannelInboundHandlerAdapter {</p>
<pre><code>@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {

        try {
            TranslatorData response = (TranslatorData) msg;
            System.out.println("Client端："+response.toString());
        }finally {
            //一定要注意，用完了缓存要进行释放
            ReferenceCountUtil.release(msg);
        }

}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
#### 7）启动类

##### 服务端NettyServerApplication
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example;</p>
<p>import com.lmax.disruptor.BlockingWaitStrategy;<br>import com.lmax.disruptor.dsl.ProducerType;<br>import org.example.consumer.MessageConsumer;<br>import org.example.factory.RingBufferWorkerPoolFactory;<br>import org.example.netty.producer.MessageConsumerHandle;<br>import org.example.netty.server.NettyServer;<br>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.SpringBootApplication;</p>
<p>@SpringBootApplication<br>public class NettyServerApplication {</p>
<pre><code>public static void main(String[] args)throws Exception {
    SpringApplication.run(NettyServerApplication.class,args);
    new NettyServer();
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


##### 客户端NettyClientApplication
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example;</p>
<p>import com.lmax.disruptor.BlockingWaitStrategy;<br>import com.lmax.disruptor.YieldingWaitStrategy;<br>import com.lmax.disruptor.dsl.ProducerType;<br>import org.example.consumer.MessageConsumer;<br>import org.example.factory.RingBufferWorkerPoolFactory;<br>import org.example.netty.client.NettyClinet;<br>import org.example.netty.consumer.MessageProducerHandle;<br>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.SpringBootApplication;</p>
<p>@SpringBootApplication<br>public class NettyClientApplication {</p>
<pre><code>public static void main(String[] args)throws Exception {
    SpringApplication.run(NettyClientApplication.class,args);
    //建立连接发送消息
    new NettyClinet().sendData();
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">
测试：

启动server

 ![](../../../../images/计算机/Java/网络编程/image-20250424141054679.png)

启动client，发送数据。

![](../../../../images/计算机/Java/网络编程/image-20250424141103906.png)

到此为止，我们已经构建好了网络模型，可以接收和发送消息了。

### 6.4.2 整合Disruptor

![](../../../../images/计算机/Java/网络编程/image-20250424141128172.png)

在使用Netty进行接收处理数据时，尽量不要在工作线程上编写自己的代理逻辑，会降低netty性能。可以利用异步机制，如使用线程池异步处理，如果使用线程池就意味使用阻塞对列，可以替换为Disruptor提高性能。

加入disruptor提升性能：

Event是客户端发到服务端的数据，serverHandler获取到Event后，不在serverHandler中对数据做处理，将Event通过生产者交给Disruptor组件。消费者c1、c2、c3通过负载均衡去消费投递过来的数据。服务端最终要返回一个响应数据给客户端。客户端这边也不是在ClientHandler中处理数据，也要构建一个生产消费者模型，有多个线程去处理。

![](../../../../images/计算机/Java/网络编程/image-20250424141402956.png)

#### 1）TranslatorDataWapper

传输的对象包装类
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.entity;</p>
<p>import io.netty.channel.ChannelHandlerContext;<br>import java.io.Serializable;</p>
<p>public class TranslatorDataWapper implements Serializable {<br>    private TranslatorData data;<br>    private ChannelHandlerContext ctx;</p>
<pre><code>public TranslatorData getData() {
    return data;
}

public TranslatorDataWapper setData(TranslatorData data) {
    this.data = data;
    return this;
}

public ChannelHandlerContext getCtx() {
    return ctx;
}

public TranslatorDataWapper setCtx(ChannelHandlerContext ctx) {
    this.ctx = ctx;
    return this;
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


#### 2）MessageProducer

生产者
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.producer;</p>
<p>import com.lmax.disruptor.RingBuffer;<br>import io.netty.channel.ChannelHandlerContext;<br>import org.example.entity.TranslatorData;<br>import org.example.entity.TranslatorDataWapper;</p>
<p>public class MessageProducer {<br>    private String producerId;<br>    private RingBuffer<translatordatawapper> ringBuffer;</translatordatawapper></p>
<pre><code>public MessageProducer(String producerId,RingBuffer&lt;TranslatorDataWapper&gt; ringBuffer){
    this.producerId = producerId;
    this.ringBuffer = ringBuffer;
}

public void onData(TranslatorData data, ChannelHandlerContext ctx){
    long sequence = ringBuffer.next();
    try {
        TranslatorDataWapper wapper = ringBuffer.get(sequence);
        wapper.setData(data);
        wapper.setCtx(ctx);
    }finally {
        ringBuffer.publish(sequence);
    }
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


#### 3）MessageConsumer

消费者
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.consumer;</p>
<p>import com.lmax.disruptor.WorkHandler;<br>import org.example.entity.TranslatorDataWapper;</p>
<p>public abstract class MessageConsumer implements WorkHandler<translatordatawapper> {<br>    protected String consumerId;</translatordatawapper></p>
<pre><code>public MessageConsumer(String consumerId) {
    this.consumerId = consumerId;
}

public String getConsumerId() {
    return consumerId;
}

public MessageConsumer setConsumerId(String consumerId) {
    this.consumerId = consumerId;
    return this;
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


#### 4）RingBufferWorkerPoolFactory

创建连接池工厂类
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.factory;</p>
<p>import com.lmax.disruptor.EventFactory;<br>import com.lmax.disruptor.ExceptionHandler;<br>import com.lmax.disruptor.RingBuffer;<br>import com.lmax.disruptor.SequenceBarrier;<br>import com.lmax.disruptor.WaitStrategy;<br>import com.lmax.disruptor.WorkerPool;<br>import com.lmax.disruptor.dsl.ProducerType;<br>import java.util.Map;<br>import java.util.concurrent.ConcurrentHashMap;<br>import java.util.concurrent.Executors;<br>import org.example.consumer.MessageConsumer;<br>import org.example.entity.TranslatorDataWapper;<br>import org.example.producer.MessageProducer;</p>
<p>public class RingBufferWorkerPoolFactory {<br>    //单例<br>    private static class SingletonHolder{<br>        static final RingBufferWorkerPoolFactory instance = new RingBufferWorkerPoolFactory();<br>    }<br>    private RingBufferWorkerPoolFactory(){}</p>
<pre><code>public static RingBufferWorkerPoolFactory getInstance(){
    return SingletonHolder.instance;
}
//需要生产者池和消费者池管理生产和消费者
private static Map&lt;String, MessageProducer&gt; producers = new ConcurrentHashMap&lt;String, MessageProducer&gt;();

private static Map&lt;String, MessageConsumer&gt; consumers = new ConcurrentHashMap&lt;String, MessageConsumer&gt;();

private RingBuffer&lt;TranslatorDataWapper&gt; ringBuffer;

private SequenceBarrier sequenceBarrier;
private WorkerPool&lt;TranslatorDataWapper&gt; workerPool;
//初始化ProducerType生产者类型，是多生产还是单生产。MessageConsumer[]多消费
public void initAndStart(ProducerType type,int bufferSize, WaitStrategy waitStrategy,MessageConsumer[] messageConsumers){
//    1、构建ringBuffer对象
    this.ringBuffer = RingBuffer.create(type, new EventFactory&lt;TranslatorDataWapper&gt;() {
        @Override
        public TranslatorDataWapper newInstance() {
            return new TranslatorDataWapper();
        }
    },bufferSize,waitStrategy);
//    2、设置序号栅栏
    this.sequenceBarrier = this.ringBuffer.newBarrier();
//    3、设置工作池
    this.workerPool = new WorkerPool&lt;TranslatorDataWapper&gt;(this.ringBuffer,this.sequenceBarrier,new  EventExceptionHandler(),messageConsumers);
    //4、把所构建的消费者置入池中
    for (MessageConsumer mc:messageConsumers) {
        this.consumers.put(mc.getConsumerId(),mc);
    }
    //5、添加我们的sequences
    this.ringBuffer.addGatingSequences(this.workerPool.getWorkerSequences());
    //6、启动我们的工作池
    this.workerPool.start(Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()/2));

}

public MessageProducer getMessageProducer(String producerId){
    //池里有直接获取生产者
    MessageProducer messageProducer = this.producers.get(producerId);
    if(null == messageProducer){
        messageProducer = new MessageProducer(producerId,this.ringBuffer);
        this.producers.put(producerId,messageProducer);
    }
    return messageProducer;
}

static class EventExceptionHandler implements ExceptionHandler&lt;TranslatorDataWapper&gt; {

    @Override
    public void handleEventException(Throwable throwable, long l, TranslatorDataWapper translatorDataWapper) {

    }

    @Override
    public void handleOnStartException(Throwable throwable) {

    }

    @Override
    public void handleOnShutdownException(Throwable throwable) {

    }
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


### 6.4.3 百万级连接接入

#### 1）修改serverHandler
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.netty.server;</p>
<p>import io.netty.channel.ChannelHandlerContext;<br>import io.netty.channel.ChannelInboundHandlerAdapter;<br>import org.example.entity.TranslatorData;<br>import org.example.factory.RingBufferWorkerPoolFactory;<br>import org.example.producer.MessageProducer;</p>
<p>public class ServerHandler extends ChannelInboundHandlerAdapter {<br>    //无disruptor<br>    //@Override<br>    //public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {<br>    //    TranslatorData request = (TranslatorData) msg;<br>    //    System.out.println(“Server端：”+request.toString());<br>    //    //数据库持久化操作 IO读写——》交给一个线程池，去异步调用执行<br>    //    TranslatorData response = new TranslatorData();<br>    //    response.setId(“resp：”+request.getId());<br>    //    response.setName(“resp：”+request.getName());<br>    //    response.setMessage(“resp：”+request.getMessage());<br>    //    //写出response响应信息：<br>    //    ctx.writeAndFlush(response);<br>    //<br>    //}</p>
<pre><code>@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
    TranslatorData request = (TranslatorData) msg;
    //自己的服务应用应该有一个ID生成规则
    String producerId = "code:seesionId:001";
    MessageProducer messageProducer = RingBufferWorkerPoolFactory.getInstance().getMessageProducer(producerId);
    messageProducer.onData(request,ctx);

}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


#### 2）MessageConsumerImpl4Server

服务器端消费者：用来处理客户端发送来数据的逻辑
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.netty.producer;</p>
<p>import io.netty.channel.ChannelHandlerContext;<br>import org.example.consumer.MessageConsumer;<br>import org.example.entity.TranslatorData;<br>import org.example.entity.TranslatorDataWapper;</p>
<p>public class MessageConsumerHandle extends MessageConsumer {<br>    public MessageConsumerHandle(String consumerId) {<br>        super(consumerId);<br>    }</p>
<pre><code>@Override
public void onEvent(TranslatorDataWapper event) throws Exception {
    TranslatorData request = event.getData();
    ChannelHandlerContext ctx = event.getCtx();
    //1、业务逻辑处理：
    System.err.println("Server端："+request.toString());
    //2、回送响应消息：
    TranslatorData response = new TranslatorData();
    response.setId("resp："+request.getId());
    response.setName("resp："+request.getName());
    response.setMessage("resp："+request.getMessage());
    //写出response响应信息
    ctx.writeAndFlush(response);
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


#### 3）修改clientHandler
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.netty.client;</p>
<p>import io.netty.channel.ChannelHandlerContext;<br>import io.netty.channel.ChannelInboundHandlerAdapter;<br>import io.netty.util.ReferenceCountUtil;<br>import org.example.entity.TranslatorData;<br>import org.example.factory.RingBufferWorkerPoolFactory;<br>import org.example.producer.MessageProducer;</p>
<p>public class ClientHandler extends ChannelInboundHandlerAdapter {</p>
<pre><code>//@Override
//public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
//
//        try {
//            TranslatorData response = (TranslatorData) msg;
//            System.out.println("Client端："+response.toString());
//        }finally {
//            //一定要注意，用完了缓存要进行释放
//            ReferenceCountUtil.release(msg);
//        }
//
//}
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        TranslatorData response = (TranslatorData) msg;
        String producerId = "code:sessionId:002";
        MessageProducer messageProducer = RingBufferWorkerPoolFactory.getInstance().getMessageProducer(producerId);
        messageProducer.onData(response,ctx);
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


#### 4）MessageConsumerImpl4Client

客户端处理服务端返回数据
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example.netty.producer;</p>
<p>import io.netty.channel.ChannelHandlerContext;<br>import org.example.consumer.MessageConsumer;<br>import org.example.entity.TranslatorData;<br>import org.example.entity.TranslatorDataWapper;</p>
<p>public class MessageConsumerHandle extends MessageConsumer {<br>    public MessageConsumerHandle(String consumerId) {<br>        super(consumerId);<br>    }</p>
<pre><code>@Override
public void onEvent(TranslatorDataWapper event) throws Exception {
    TranslatorData request = event.getData();
    ChannelHandlerContext ctx = event.getCtx();
    //1、业务逻辑处理：
    System.err.println("Server端："+request.toString());
    //2、回送响应消息：
    TranslatorData response = new TranslatorData();
    response.setId("resp："+request.getId());
    response.setName("resp："+request.getName());
    response.setMessage("resp："+request.getMessage());
    //写出response响应信息
    ctx.writeAndFlush(response);
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


#### 5）启动类

##### 服务端
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example;</p>
<p>import com.lmax.disruptor.BlockingWaitStrategy;<br>import com.lmax.disruptor.dsl.ProducerType;<br>import org.example.consumer.MessageConsumer;<br>import org.example.factory.RingBufferWorkerPoolFactory;<br>import org.example.netty.producer.MessageConsumerHandle;<br>import org.example.netty.server.NettyServer;<br>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.SpringBootApplication;</p>
<p>@SpringBootApplication<br>public class NettyServerApplication {</p>
<pre><code>//public static void main(String[] args)throws Exception {
//    SpringApplication.run(NettyServerApplication.class,args);
//    new NettyServer();
//}

public static void main(String[] args)throws Exception {
    SpringApplication.run(NettyServerApplication.class,args);
    MessageConsumer[] consumers = new MessageConsumer[4];

    for(int i=0;i&lt; consumers.length;i++){
        MessageConsumer messageConsumer = new MessageConsumerHandle("code:serverId:"+i);
        consumers[i] = messageConsumer;
    }

    RingBufferWorkerPoolFactory.getInstance().initAndStart(ProducerType.MULTI,1024*1024,new BlockingWaitStrategy(),consumers);
    new NettyServer();
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


##### 客户端
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>package org.example;</p>
<p>import com.lmax.disruptor.BlockingWaitStrategy;<br>import com.lmax.disruptor.YieldingWaitStrategy;<br>import com.lmax.disruptor.dsl.ProducerType;<br>import org.example.consumer.MessageConsumer;<br>import org.example.factory.RingBufferWorkerPoolFactory;<br>import org.example.netty.client.NettyClinet;<br>import org.example.netty.consumer.MessageProducerHandle;<br>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.SpringBootApplication;</p>
<p>@SpringBootApplication<br>public class NettyClientApplication {</p>
<pre><code>//public static void main(String[] args)throws Exception {
//    SpringApplication.run(NettyClientApplication.class,args);
//    //建立连接发送消息
//    new NettyClinet().sendData();
//}


public static void main(String[] args)throws Exception {
    SpringApplication.run(NettyClientApplication.class,args);
    MessageConsumer[] consumers = new MessageConsumer[4];
    for(int i=0;i&lt;consumers.length;i++){
        MessageConsumer messageConsumer = new MessageProducerHandle("code:clientId:"+i);
        consumers[i] = messageConsumer;
    }
    RingBufferWorkerPoolFactory.getInstance().initAndStart(ProducerType.MULTI,
            1024*1024,
            //new YieldingWaitStrategy(),
            new BlockingWaitStrategy(),
            consumers);
    //建立连接发送消息
    new NettyClinet().sendData();
}
</code></pre>
<p>}</p>
<pre class="line-numbers language-none"><code class="language-none">


#### 6）测试
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>//发送数据的方法，提供给外部使用
public void sendData() {
    for (int i = 0; i &lt; 6000000; i++) {
        TranslatorData request = new TranslatorData();
        request.setId(String.valueOf(i));
        request.setName("请求消息名称 "+i);
        request.setMessage("请求消息内容 "+i);
        this.channel.writeAndFlush(request);
    }
}
</code></pre>
<pre><code>


可以看到百万级别的连接已经建立

![](../../../../images/计算机/Java/网络编程/image-20250424142002871.png)

![](../../../../images/计算机/Java/网络编程/image-20250424142008597.png)
</code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://gustavo1841.github.io" rel="external nofollow noreferrer">Gustavo</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://gustavo1841.github.io/2025/04/24/ji-suan-ji/java/wang-luo-bian-cheng/wang-luo-bian-cheng-xia/">https://gustavo1841.github.io/2025/04/24/ji-suan-ji/java/wang-luo-bian-cheng/wang-luo-bian-cheng-xia/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://gustavo1841.github.io" target="_blank">Gustavo</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/">
                                    <span class="chip bg-color">计算机</span>
                                </a>
                            
                                <a href="/tags/Java/">
                                    <span class="chip bg-color">Java</span>
                                </a>
                            
                                <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">
                                    <span class="chip bg-color">网络编程</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'Ov23liq75W6OMBRsILFM',
        clientSecret: 'ed377d268bc9ef7ea8e847b6de012be660bd8e3e',
        repo: 'gustavo1841.github.io',
        owner: 'gustavo1841',
        admin: "gustavo1841",
        id: '2025-04-24T09-30-54',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2025/04/25/ji-suan-ji/java/shu-ju-ku-zhuan-ti/guan-xi-xing/shu-ju-ku-xi-tong-yuan-li-mysql-jia-gou-pian/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/777.jpg" class="responsive-img" alt="数据库系统原理——MySQL架构篇">
                        
                        <span class="card-title">数据库系统原理——MySQL架构篇</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2025-04-25
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="post-category">
                                    计算机
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/">
                        <span class="chip bg-color">计算机</span>
                    </a>
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                    <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">
                        <span class="chip bg-color">数据库</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2025/04/24/ji-suan-ji/java/wang-luo-bian-cheng/wang-luo-bian-cheng-shang/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/278.jpg" class="responsive-img" alt="网络编程—上">
                        
                        <span class="card-title">网络编程—上</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-04-24
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="post-category">
                                    计算机
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/">
                        <span class="chip bg-color">计算机</span>
                    </a>
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                    <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">
                        <span class="chip bg-color">网络编程</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: Gustavo<br />'
            + '文章作者: Gustavo<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1,h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2025</span>
            
            <a href="/about" target="_blank">Gustavo</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">1357.9k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2025";
                        var startMonth = "1";
                        var startDate = "13";
                        var startHour = "18";
                        var startMinute = "54";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/gustavo1841" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:huangwei0246@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1142488172" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1142488172" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    
        <!-- <script src='https://unpkg.com/mermaid@latest/dist/mermaid.min.js'></script> -->
        <script src='/libs/mermaid/mermaid.min.js'></script>
        <script>
          if (window.mermaid) {
            mermaid.initialize({theme: 'forest'});
          }
        </script>
    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
